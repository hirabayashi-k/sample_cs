namespace UnionTypes
{
    class Program
    {
        /// <summary>
        /// <see cref="IUnion{T}"/>みたいな型、要するに「値、もしくは、配列のどちらか片方を持つ型」の実装方式で何が一番コスト低いかを調べる。
        ///
        /// 実行結果は微々たる差(特にReleaseビルドだと差が出ない。せいぜい5%、よく順番もひっくり返る)だった。
        /// 
        /// 一応、順序的には、
        /// 速
        /// 4: 常に配列で持つ。長さ1の配列と値の区別がつかないので不完全
        /// 2: object で持つ
        /// 1: T と T[] の2つのフィールドで持つ
        /// 3: 派生クラスで分岐
        /// 5: 4にちゃんと値と配列を弁別するためのフラグを足したもの
        /// 遅
        ///
        /// 印象としては、
        /// - コピーのコスト大きい。native intサイズを超えた時点でbox化の方が有効
        /// - as も案外コスト
        /// - さすがに3みたいに常に間接参照が1段階挟まるのは損
        /// </summary>
        static void Main(string[] args)
        {
            Runner.Run();
            Runner.Run();
        }
    }
}
